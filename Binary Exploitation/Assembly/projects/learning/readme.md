### Me learning

Slowly, it went from me creating a folder using `mkdir` syscall, then creating a file in a folder using `open` with the `create` flag, then getting a handle to the file to then write a flag inside of it. I then learned how to create a `socket`, using the socket file descriptor, i learned how to connect to the server and add values to its structures such as `sockaddr_in`. Then retrieve information from the server using `recvfrom` syscall.  I then creating an encryption function that xor'd the data and write the data to standardout using `write`, then decrypt the data and `write` it again. Finally closing the handle once done.

```asm
section .text
global _start

exit:
        ; syscall(exit, 0x0)
        mov rsi, 0x0
        mov rax, 0x3c ; exit
        syscall

encrypt_traffic:
        mov rdi, rsi ; buffer
        mov rcx, rax ; buffer_length
.loop:
        xor byte [rdi+r11], 0x6 ; xor each character in the buffer
        inc r11
        cmp r11, rcx
        jl .loop
        mov rax, rdi
        ret

_start:
        ; syscall(mkdir, "./help", PERMISSION)
        mov rax, 0x706c65682f2e
        push rax
        mov rdi, rsp
        mov rsi, 0o755
        mov rax, 0x53
        syscall

        ; syscall(open, "./help/.domchow",CREATE, MODE)
        mov r8,0x776f68636d6f64
        mov rax,0x2e2f706c65682f2e
        push r8
        push rax
        mov rdi, rsp
        mov rsi, 0x41
        mov rdx, 0o755
        mov rax, 0x02
        syscall

        ; syscall(open, "./help/.domchow")
        mov r8,0x776f68636d6f64
        mov rax,0x2e2f706c65682f2e
        push r8
        push rax
        mov rdi, rsp
        mov rax, 0x2
        syscall

        ; syscall(write, fd, "flag{th1s_1s_ep1c_yo!}", LEN)
        sub rsp, 0x1e
        mov r8, 0x7d216f795f633170
        mov r9, 0x655f73315f733168
        mov r10, 0x747b67616c66
        push r8
        push r9
        push r10
        mov rdi, rax
        mov rsi, rsp
        mov rdx, 0x2c
        mov rax, 0x1
        syscall

        ; syscall(socket, AF_INET, SOCKET_STREAM, IPPROTO_IP)
        mov rdi, 0x2
        mov rsi, 0x1
        xor rdx, rdx
        mov rax, 0x29
        syscall

        ; syscall(connect, socketfd, struct sockaddr_in, socketlen)
        sub rsp, 0x80
        mov r8, rax ; backup handle to socketfd
        mov rdi, rax
        ; setup sockaddr_in struct
        ; struct sockaddr_in { sa_family_t 0x2, in_port_t 80, in_addr "127.0.0.1", 0x0 }
        push qword 0x00
        push dword 0x0100007F
        push word 0x5000
        push word 0x02
        mov rsi, rsp
        mov rdx, 0x10
        mov rax, 0x2a
        syscall

        ; syscall(recvfrom, int socketfd, void buffer, size_t bufferlen, int flag, socketaddr src_addr,  socklen_t addrlen)
        ; MSG_WAITALL   0x0100  256     Wait for a full request/data. The call blocks until the requested number of bytes have been received.
        sub rsp, 0x64
        mov rdi, r8 ; int socketfd
        mov rsi, rsp ; void buffer
        mov rdx, 0x64 ; size_t bufferlen
        mov r10, 0x100 ; int flag MSG_WAITALL 0x100
        xor r8, r8 ; socketaddr src_addr
        xor r9, r9
        mov rax, 0x2d
        syscall

        ; Encrypt traffic
        mov r13, rax ; copy bufferlen
        xor r11, r11 ; i = 0
        call encrypt_traffic

        ; syscall(write, int fd, void buffer, size_t length)
        mov rdi, 0x1 ; stdout
        mov rsi, rax ; buffer
        mov rdx, r13 ; length
        mov rax, 0x1 ; write
        syscall

        ; Decrypt traffic
        xor r11, r11 ; i = 0
        call encrypt_traffic

        ; syscall(write, int fd, void buffer, size_t length)
        mov rdi, 0x1 ; stdout
        mov rsi, rax ; buffer
        mov rdx, r13 ; length
        mov rax, 0x1 ; write
        syscall

        ; syscall(close, int fd)
        mov rdi, r8 ; socketfd
        mov rax, 0x3 ; close
        syscall

        call exit
```
